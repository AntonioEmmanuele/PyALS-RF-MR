-- Copyright 2021-2023 Salvatore Barone <salvatore.barone@unina.it>
--
-- This file has been auto-generated by pyALS-rf
-- https://github.com/SalvatoreBarone/pyALS-rf
--
-- This is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by the Free
-- Software Foundation; either version 3 of the License, or any later version.
--
-- This is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-- more details.
--
-- You should have received a copy of the GNU General Public License along with
-- RMEncoder; if not, write to the Free Software Foundation, Inc., 51 Franklin
-- Street, Fifth Floor, Boston, MA 02110-1301, USA.

library ieee;
use ieee.std_logic_1164.all;
library work;
use work.common_types.all;

entity classifier is
  generic (
    data_width      : natural := {{ data_width }};
    parallel_blocks : natural := 8;
    threshold_val   : natural := {{ threshold_val }};
    {% for f in features -%}
    nab_{{f['name']}} : natural := {{f['nab']}}{{";" if not loop.last else ""}}
    {% endfor %}
  );  -- ✅ proper generic closure

  port (
    clock   : in std_logic;
    reset_n : in std_logic;
    enable  : in std_logic;
    {% for feature in features -%}
    {{feature['name']}} : in std_logic_vector(data_width-1 downto nab_{{feature['name']}});{% endfor %}
    {% for c in classes -%}
    class_{{c}} : out std_logic{{"" if loop.last else ";"}}
    {% endfor %}
  );  -- ✅ no semicolon after last output
end classifier;

architecture structural of classifier is

  component pipe_reg is
    generic (
      data_width : natural
    );
    port (
      clock    : in  std_logic;
      reset_n  : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector (data_width-1 downto 0);
      data_out : out std_logic_vector (data_width-1 downto 0)
    );
  end component;

  constant n_trees   : natural := {{trees|length}};
  constant n_classes : natural := {{classes|length}};

  {% for name, inputs in trees.items() %}
  component decision_tree_{{name}} is
    generic (
      data_width      : natural;
      parallel_blocks : natural{% if inputs|length > 0 %};{% endif %}
      {% for feature in inputs -%}
      nab_{{feature['name']}} : natural{{";" if not loop.last else ""}}
      {% endfor %}
    );
    port (
      clock   : in std_logic;
      reset_n : in std_logic;
      {% for feature in inputs -%}
      {{feature['name']}} : in std_logic_vector(data_width-1 downto nab_{{feature['name']}});{% endfor %}
      {% for c in classes -%}
      class_{{c}} : out std_logic{{";" if not loop.last else ""}}
      {% endfor %}
    );
  end component;{{"\n  " if not loop.last}}
  {% endfor %}

  component mr_solver is
    generic (
      THRESHOLD_VAL : natural := 0;
      COMP_OP       : comp_operator_t := lessThan
    );
    port (
      clock   : in  std_logic;
      reset_n : in  std_logic;
      enable  : in  std_logic;
      din32   : in  std_logic_vector(31 downto 0);
      result  : out std_logic
    );
  end component;

  {% for feature in features -%}
  signal buffered_{{feature['name']}} : std_logic_vector(data_width-1 downto nab_{{feature['name']}}) := (others => '0');
  {% endfor %}

  {% for c in classes -%}
  signal class_{{c}}_results : std_logic_vector(n_trees-1 downto 0) := (others => '0');
  {% endfor %}

  {% for c in candidates -%}
  signal candidate_{{c}}_preferences : std_logic_vector(31 downto 0) := (others => '0');
  signal mr_out_{{c}} : std_logic := '0';
  {% endfor %}

begin

  -- Pipeline buffering for all features
  {% for feature in features -%}
  buffer_4_{{feature['name']}} : pipe_reg
    generic map (
      data_width => data_width - nab_{{feature['name']}}
    )
    port map (
      clock   => clock,
      reset_n => reset_n,
      enable  => enable,
      data_in  => {{feature['name']}},
      data_out => buffered_{{feature['name']}}
    );
  {% endfor %}

  -- Decision tree instantiation
  {% for name, inputs in trees.items() %}{% set outer_loop = loop %}
  tree_{{name}} : decision_tree_{{name}}
    generic map (
      data_width      => data_width,
      parallel_blocks => parallel_blocks{% if inputs|length > 0 %},{% endif %}
      {% for feature in inputs -%}
      nab_{{feature['name']}} => nab_{{feature['name']}}{{"," if not loop.last else ""}}
      {% endfor %}
    )
    port map (
      clock   => clock,
      reset_n => reset_n,
      {% for feature in inputs -%}
      {{feature['name']}} => buffered_{{feature['name']}},{% endfor %}
      {% for c in classes -%}
      class_{{c}} => class_{{c}}_results({{outer_loop.index-1}}){{"," if not loop.last else ""}}
      {% endfor %}
    );
  {% endfor %}

  -- Modular redundancy solvers
  {% for c in candidates -%}{% set class_i = loop.index0 -%}
  {% for t in approximate_configuration[class_i] -%}
  candidate_{{c}}_preferences({{loop.index0}}) <= class_{{c}}_results({{t}});
  {% endfor %}

  mr_{{c}} : mr_solver
    generic map (
      THRESHOLD_VAL => threshold_val,
      COMP_OP       => lessThan
    )
    port map (
      clock   => clock,
      reset_n => reset_n,
      enable  => enable,
      din32   => candidate_{{c}}_preferences,
      result  => mr_out_{{c}}
    );

  class_{{c}} <= not mr_out_{{c}};
  {% endfor %}

end structural;
