-- Copyright 2021-2025 Salvatore Barone <salvatore.barone@unina.it>
-- 
-- This file has been auto-generated by pyALS-rf
-- https://github.com/SalvatoreBarone/pyALS-rf 
-- 
-- This is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by the Free
-- Software Foundation; either version 3 of the License, or any later version.
-- 
-- This is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-- more details.
-- 
-- You should have received a copy of the GNU General Public License along with
-- RMEncoder; if not, write to the Free Software Foundation, Inc., 51 Franklin
-- Street, Fifth Floor, Boston, MA 02110-1301, USA.

-- Author: Antonio Emmanuele, antonio.emmanuele@unina.it

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.common_types.all;  -- comp_operator_t, data_type_t (int)

entity mr_solver is
  generic (
    -- Threshold generica (0..32)
    THRESHOLD_VAL  : natural := 20;

    -- Operatore di confronto (es. greaterThan, lessThan, equal)
    COMP_OP        : comp_operator_t := greaterThan
  );
  port (
    clock   : in  std_logic;
    reset_n : in  std_logic;
    enable  : in  std_logic;

    din32   : in  std_logic_vector(31 downto 0);  -- input 32 bit

    result  : out std_logic                       -- output
  );
end entity mr_solver;

architecture rtl of mr_solver is

  ---------------------------------------------------------------------------
  -- Required components
  ---------------------------------------------------------------------------
  component pipe_reg is
    generic (data_width : natural);
    port (
      clock    : in  std_logic;
      reset_n  : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector (data_width-1 downto 0);
      data_out : out std_logic_vector (data_width-1 downto 0)
    );
  end component;

  component decision_box is
    generic (
      data_width      : natural;
      data_type       : data_type_t;
      comp_operator   : comp_operator_t;
      parallel_blocks : natural
    );
    port (
      clock   : in  std_logic;
      reset_n : in  std_logic;
      enable  : in  std_logic;
      data_1  : in  std_logic_vector (data_width-1 downto 0);
      data_2  : in  std_logic_vector (data_width-1 downto 0);
      result  : out std_logic
    );
  end component;

  ---------------------------------------------------------------------------
  -- Local constants
  ---------------------------------------------------------------------------
  constant PARALLEL_BLOCKS : natural := 8;  -- comparator parallelism
  constant OUT_BITS_PC     : natural := 6;  -- requires 16 bits
  constant COMP_WIDTH      : natural := 8;  -- 8 bit comparator

  -- Input threshold
  constant THR_VEC_8 : std_logic_vector(COMP_WIDTH-1 downto 0) :=
      std_logic_vector(to_unsigned(THRESHOLD_VAL, COMP_WIDTH));

  ---------------------------------------------------------------------------
  -- Internal signals
  ---------------------------------------------------------------------------
  signal din32_buf  : std_logic_vector(31 downto 0) := (others => '0');      -- pipe in
  signal pc_u6      : unsigned(OUT_BITS_PC-1 downto 0) := (others => '0');   -- popcount combinatorio
  signal pc_u6_vec  : std_logic_vector(OUT_BITS_PC-1 downto 0) := (others => '0');
  signal pc_reg_vec : std_logic_vector(OUT_BITS_PC-1 downto 0) := (others => '0');  -- pipe popcount
  signal pc_ext8    : std_logic_vector(COMP_WIDTH-1 downto 0) := (others => '0');   -- esteso a 8 bit

begin
  ----------------------------------------------------------------------------
  -- 32 bit input pipe
  ----------------------------------------------------------------------------
  in_pipe : pipe_reg
    generic map (data_width => 32)
    port map (
      clock    => clock,
      reset_n  => reset_n,
      enable   => enable,
      data_in  => din32,
      data_out => din32_buf
    );

  ----------------------------------------------------------------------------
  --  One bit counter din32_buf
  ----------------------------------------------------------------------------
  popcount_proc : process(din32_buf)
    variable sum : integer range 0 to 32 := 0;
  begin
    sum := 0;
    for i in din32_buf'range loop
      if din32_buf(i) = '1' then
        sum := sum + 1;
      end if;
    end loop;
    pc_u6 <= to_unsigned(sum, OUT_BITS_PC);
  end process;

  pc_u6_vec <= std_logic_vector(pc_u6);

  ----------------------------------------------------------------------------
  -- Output pipe of popcount (6 bit)
  ----------------------------------------------------------------------------
  pc_pipe : pipe_reg
    generic map (data_width => OUT_BITS_PC)
    port map (
      clock    => clock,
      reset_n  => reset_n,
      enable   => enable,
      data_in  => pc_u6_vec,
      data_out => pc_reg_vec
    );

  ----------------------------------------------------------------------------
  --   8 bit zero-extension for the comparator
  ----------------------------------------------------------------------------
  pc_ext8 <= (COMP_WIDTH-1 downto OUT_BITS_PC => '0') & pc_reg_vec;

  ----------------------------------------------------------------------------
  -- Integer decision box
  ----------------------------------------------------------------------------
  cmp_box : decision_box
    generic map (
      data_width      => COMP_WIDTH,
      data_type       => int,
      comp_operator   => COMP_OP,
      parallel_blocks => PARALLEL_BLOCKS
    )
    port map (
      clock   => clock,
      reset_n => reset_n,
      enable  => enable,
      data_1  => pc_ext8,     -- Popcount output
      data_2  => THR_VEC_8,   -- output
      result  => result
    );

end architecture;
